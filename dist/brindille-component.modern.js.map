{"version":3,"file":"brindille-component.modern.js","sources":["../src/index.ts"],"sourcesContent":["type ComponentCtor = new () => Component\r\ntype DefinitionGetter = (id: string) => ComponentCtor\r\ninterface DefinitionObject {\r\n  [id: string]: ComponentCtor\r\n}\r\n\r\n/**\r\n * Component class\r\n *\r\n * @class\r\n *\r\n * @author Guillaume Gouessan <guillaume.gouessan@gmail.com>\r\n *\r\n * @example\r\n * // By using an object of definitions\r\n * const component = new Component(document.body, {SubComponentClass, OtherSubComponentClass})\r\n * // By using a method that returns a definition from a given string\r\n * const component = new Component(document.body, name => name === 'SubComponentClass' ? SubComponentClass : OtherSubComponentClass)\r\n */\r\nexport default class Component {\r\n  parent: Component\r\n  root: Component\r\n\r\n  componentName: string = ''\r\n  refs: Object = {}\r\n  definitions: DefinitionGetter\r\n\r\n  private _componentInstances: Component[] = []\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {Node} $el dom element that this component will be built around\r\n   * @param {Object|Function} definitions Optional Object of Class Definitions or function that returns a Class Definitions from a given string\r\n   */\r\n  constructor(\r\n    public $el,\r\n    definitions: DefinitionObject | DefinitionGetter = null\r\n  ) {\r\n    this.root = this\r\n    this.parent = null\r\n    if (definitions) this.init(definitions)\r\n  }\r\n\r\n  /**\r\n   * Returns dom done from css selector inside this component\r\n   * @param {String} selector css selector\r\n   * @returns {HTMLElement}\r\n   */\r\n  $one(selector: string): HTMLElement {\r\n    return this.$el.querySelector(selector)\r\n  }\r\n\r\n  /**\r\n   * Returns an array of all node element matching selector that are inside this component\r\n   * @param {String} selector css selector\r\n   * @returns {Array<HTMLElement>}\r\n   */\r\n  $all(selector: string): HTMLElement[] {\r\n    return [].slice.call(this.$el.querySelectorAll(selector))\r\n  }\r\n\r\n  /**\r\n   * This will be called either by constructor if definitions are passed or by parent's parse method.\r\n   * Definitions all automatically passed down to children components and you most likely will not need to\r\n   * override or call this function.\r\n   * @param {Object|Function} definitions Object of Class Definitions or function that returns a Class Definitions from a given string\r\n   */\r\n  init(definitions: DefinitionObject | DefinitionGetter = null): void {\r\n    if (definitions instanceof Function) {\r\n      this.definitions = definitions\r\n    } else if (definitions == null) {\r\n      this.definitions = () => null\r\n    } else {\r\n      this.definitions = name => definitions[name]\r\n    }\r\n\r\n    this.parse()\r\n    if (this.root === this) {\r\n      this.onAppReady()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Will be called once whole nested parsing is done, DO NOT MANUALLY CALL THIS FUNCTION\r\n   * if you override it don't forget call to super\r\n   */\r\n  onAppReady(): void {\r\n    this._componentInstances.forEach(component => component.onAppReady())\r\n  }\r\n\r\n  /**\r\n   * Call this function when you want to remove and destroy a component\r\n   */\r\n  dispose(): void {\r\n    this.disposeChildren()\r\n    this.destroy()\r\n  }\r\n\r\n  /**\r\n   * Call dispose function of each children components\r\n   */\r\n  disposeChildren(): void {\r\n    this._componentInstances.forEach(component => {\r\n      component.dispose()\r\n    })\r\n    this._componentInstances = []\r\n    this.refs = {}\r\n  }\r\n\r\n  /**\r\n   * This will trigger a total reparsing of this component after killing its current childComponents, use at your own risk\r\n   * @param {String} htmlString new HTML to parse\r\n   */\r\n  replaceContent(htmlString: string): void {\r\n    this.disposeChildren()\r\n    this.$el.innerHTML = htmlString\r\n    this.parse()\r\n  }\r\n\r\n  /**\r\n   * Removes component from parent if it exists and deletes dom references\r\n   */\r\n  destroy(): void {\r\n    if (\r\n      this.parent &&\r\n      this.$el.parentNode &&\r\n      this.$el.parentNode === this.parent.$el\r\n    ) {\r\n      this.parent.$el.removeChild(this.$el)\r\n    }\r\n    this.parent = null\r\n    this.$el = null\r\n  }\r\n\r\n  /**\r\n   * Returns first instance of Component with the name given as parameter\r\n   * @param {String} componentName name of the component to find\r\n   * @returns {Component} Component instance found, null if no result\r\n   */\r\n  findInstance(componentName: string): Component {\r\n    // Start By looking in direct children\r\n    const instance = this._componentInstances.filter(\r\n      value => value.componentName === componentName\r\n    )\r\n    if (instance && instance.length) return instance[0]\r\n\r\n    // If nothing found, try in children's children\r\n    for (let i = 0, l = this._componentInstances.length; i < l; i++) {\r\n      const childInstance = this._componentInstances[i].findInstance(\r\n        componentName\r\n      )\r\n      if (childInstance) return childInstance\r\n    }\r\n\r\n    // Still nothing means no instance found\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * Returns all instances of Component with the name given as parameter\r\n   * @param {String} componentName name of the component to find\r\n   * @returns {Component[]} an array of Components\r\n   */\r\n  findAllInstances(componentName: string): Component[] {\r\n    let instances = this._componentInstances.filter(\r\n      value => value.componentName === componentName\r\n    )\r\n\r\n    for (let i = 0, l = this._componentInstances.length; i < l; i++) {\r\n      instances = instances.concat(\r\n        this._componentInstances[i].findAllInstances(componentName)\r\n      )\r\n    }\r\n\r\n    return instances\r\n  }\r\n\r\n  /**\r\n   * Looks into this component children and creates its sub components if any is found.\r\n   * Sub component instances with data-ref attributes will be added to the refs object of current Component.\r\n   */\r\n  parse(): void {\r\n    findComponents(this.$el, node => {\r\n      const componentName =\r\n        node && node.getAttribute ? node.getAttribute('data-component') : ''\r\n      let Ctor\r\n      let component\r\n      if (node.nodeType === 1 && componentName) {\r\n        if (node.tagName === 'FORM') {\r\n          console.warn(\r\n            `FORM tag does not support data-component. You should encapsulate the <form> with a <div> in component ${componentName}`\r\n          )\r\n        }\r\n\r\n        Ctor = this.definitions(componentName)\r\n\r\n        if (Ctor) {\r\n          node.removeAttribute('data-component')\r\n          component = new Ctor(node)\r\n          component.componentName = componentName\r\n          component.parent = this\r\n          component.root = this.root\r\n          component.init(this.definitions)\r\n          this._componentInstances.push(component)\r\n\r\n          if (node.getAttribute('data-ref')) {\r\n            this.refs[node.getAttribute('data-ref')] = component\r\n          }\r\n        } else {\r\n          console.warn(`Can't find component '${componentName}'`)\r\n        }\r\n      }\r\n    })\r\n\r\n    this.ready()\r\n  }\r\n\r\n  /**\r\n   * This is where you want to put the logic of the component\r\n   */\r\n  ready(): void {}\r\n\r\n  get componentInstances(): Component[] {\r\n    return this._componentInstances\r\n  }\r\n}\r\n\r\n/**\r\n * Makes sure to put whatever obj is in an array if obj is not an array\r\n * @param {*} obj\r\n */\r\nfunction toArray(obj: any) {\r\n  return obj == null ? [] : Array.isArray(obj) ? obj : [obj]\r\n}\r\n\r\n/**\r\n * Recursively Applies a callback on each Node that is found to be a Component\r\n * @param {Array} nodes an array of Node\r\n * @param {*} callback function to call on each Node that has data-component\r\n */\r\nfunction findComponents(nodes, callback) {\r\n  nodes = toArray(nodes)\r\n  nodes = [].slice.call(nodes)\r\n  let node\r\n  for (let i = 0, l = nodes.length; i < l; i++) {\r\n    node = nodes[i]\r\n    if (node && node.hasAttribute && node.hasAttribute('data-component')) {\r\n      callback(node)\r\n    } else if (node.childNodes && node.childNodes.length) {\r\n      findComponents([].slice.call(node.childNodes), callback)\r\n    }\r\n  }\r\n}\r\n"],"names":["constructor","$el","definitions","this","root","parent","init","$one","selector","querySelector","$all","slice","call","querySelectorAll","Function","name","parse","onAppReady","_componentInstances","forEach","component","dispose","disposeChildren","destroy","refs","replaceContent","htmlString","innerHTML","parentNode","removeChild","findInstance","componentName","instance","filter","value","length","i","l","childInstance","findAllInstances","instances","concat","findComponents","nodes","callback","node","obj","Array","isArray","hasAttribute","childNodes","getAttribute","Ctor","nodeType","tagName","console","warn","removeAttribute","push","ready","componentInstances"],"mappings":"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"}